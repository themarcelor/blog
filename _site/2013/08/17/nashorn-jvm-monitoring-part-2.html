<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Nashorn Jvm Monitoring Part 2 | TheMarceloR</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Nashorn Jvm Monitoring Part 2" />
<meta name="author" content="Marcelo Costa" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hello and welcome to the second part of the â€œNashorn and the JVM Monitoring Challengeâ€ series" />
<meta property="og:description" content="Hello and welcome to the second part of the â€œNashorn and the JVM Monitoring Challengeâ€ series" />
<link rel="canonical" href="http://localhost:4000/2013/08/17/nashorn-jvm-monitoring-part-2.html" />
<meta property="og:url" content="http://localhost:4000/2013/08/17/nashorn-jvm-monitoring-part-2.html" />
<meta property="og:site_name" content="TheMarceloR" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-08-17T00:00:00+01:00" />
<script type="application/ld+json">
{"description":"Hello and welcome to the second part of the â€œNashorn and the JVM Monitoring Challengeâ€ series","author":{"@type":"Person","name":"Marcelo Costa"},"@type":"BlogPosting","url":"http://localhost:4000/2013/08/17/nashorn-jvm-monitoring-part-2.html","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo.png"},"name":"Marcelo Costa"},"headline":"Nashorn Jvm Monitoring Part 2","dateModified":"2013-08-17T00:00:00+01:00","datePublished":"2013-08-17T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2013/08/17/nashorn-jvm-monitoring-part-2.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">TheMarceloR</a></h1>
        
        
          <img src="/assets/img/logo.png" alt="Logo" />
        

        <p>::Troubleshooting, Coding and Comic Books</p>

        

        

        
        <nav>
<ul>
  <li>
    <a href="/about.html">About</a>
  </li>
</ul>
</nav>

      </header>
      <section>
      
      <h1>Nashorn Jvm Monitoring Part 2</h1>
<p>17 Aug 2013 - Marcelo Costa</p>

<p>Hello and welcome to the second part of the â€œNashorn and the JVM Monitoring Challengeâ€ series</p>

<p>Hello and welcome to the second part of the â€œNashorn and the JVM Monitoring Challengeâ€ series, we will continue our quest to unveil what kind of chaotic things we will see once the JVM starts processing the bytecode that is executing untyped dynamic languages.</p>

<p>Letâ€™s start with some good news: You donâ€™t have to follow the OpenJDK Build instructions to start playing with Nashorn anymore, it was finally integrated to an early build of the Oracleâ€™s JDK 8, I havenâ€™t tried myself (Still playing in Ubuntu 12 with OpenJDK 8) but it should be there.</p>

<p>So, letâ€™s get started, the agenda for today is going to be:</p>

<p>Running a test script with the Nashorn Javascript engine
Understanding Invokedynamic (It should be helpful to dive more into what we are going to see later)
Monitor the JVM while running a Nashorn application
Running a test script
The Nashorn engine can be loaded in a Java class and then, with the instance of the ScriptEngine object, use the eval() method to execute Javascript code. Just write and compile the following class:</p>

<p>import javax.script.*;
public class EvalFile {
 public static void main(String[] args) throws Exception {
     // create a script engine manager
     ScriptEngineManager factory = new ScriptEngineManager();
     // create JavaScript engine
     ScriptEngine engine = factory.getEngineByName(â€œnashornâ€);
     // evaluate JavaScript code from given file - specified by first argument
     engine.eval(new java.io.FileReader(args[0]));
 }
}
Once you have your â€˜EvalFileâ€™ class ready, create a dummy .js file just to give it a try, write something like:</p>

<p>print(â€˜Hello Worldâ€™);
Then you can execute this script like this:</p>

<p>java -cp nashorn.jar:. EvalFile dummy.js
In order to speed things up, Iâ€™ve created an alias to invoke the â€˜jjsâ€™ command-line tool so I donâ€™t have to use this EvalFile class.</p>

<p>$alias jjs=â€™/var/jdk8/openjdk8/nashorn/bin/jjsâ€™
now, the .js file can be executed like this:</p>

<p>jjs dummy.js
Moving on, my test script here will only be used to explore how we can keep track of the chain of function calls and the number/size of objects that are being allocated into the JVMâ€™s heap, if you really want to experience the power of Nashorn, you can refer to the official â€˜Java Scripting Programmerâ€™s Guideâ€˜.</p>

<p>This test comprises two files:</p>

<p>â€” Model.js â€”</p>

<p>function Person(name, address, phone) {
    this.name = name;
    this.address = address;
    this.phone = phone;
    this.sayHello = function() {
        return â€œHi, my name is â€œ + this.name;
    }
}
â€” testNashorn.js â€”</p>

<p>#!/usr/bin/jjs
#
var Thread = java.lang.Thread;
load(â€œ./Model.jsâ€);
print(â€œWelcome to testNashorn.jsâ€);
var people = [];
for(var i=0;i&lt;100;i++){
    var p = new Person(â€œMarceloâ€,â€Caucaia Street 17â€,â€+353 086 5555555â€);
    people.push(p);
}
//Lots of objects were allocated into memory at this point 
Thread.sleep(30000);
var myFunction = function(){
    var text = people[0].sayHello();
    print(text);
};
myFunction();
The first one (Model.js) is where Iâ€™m declaring my Person â€œClassâ€, 3 attributes and 1 meth.. sorry, function, the second file (testNashorn.js) is the actual program, it first transforms the Thread Java class into a Javascript variable, then loads the Model.js, i.e., runs the Javascript code inside that file and prepares our Person() function/constructor, it declares an empty objects array and enters a loop instruction that is going to create 100 objects in memory, after the â€˜forâ€™ loop, as I will need a second to trigger my script to generate a heap dump, I decided to add a â€˜Thread.sleep(30000)â€™ there (30 secs is more than enough), once the program awakes, it declares a function (myFunction) that is going to print the value returned by the â€˜sayHello()â€™ function from the first object stored in the â€˜peopleâ€™ array, this function is then called right afterwards.</p>

<p>Now, we can run the program:</p>

<p>jjs testNashorn.js
The output should be something like this:</p>

<p>Welcome to testNashorn.js
[30 sec pause]
Hi, my name is Marcelo
Thatâ€™s it, we have our test script, letâ€™s move on to the second topic.</p>

<p>Understanding invokedynamic
Ok, we already know that the Nashorn Javascript engine is 100% compliant with ECMA-262 5.1 and it is fully implemented with the new â€œinvokedynamicâ€ bytecode instruction, therefore, is faster and more compliant than Mozillaâ€™s Rhino, but whatâ€™s invokedynamic?</p>

<p>Executing Java code is not the JVMâ€™s solely purpose, every Java code is compiled into bytecode and this is the piece that gets consumed and processed by the JVM, if a programming language can be compiled to bytecode than its instructions can be interpreted by the JVM (e.g., Closure or Scala). The bytecode is an efficient simplified form of non-human-readable code that is executed closer to machine-level instructions, i.e., better performance.</p>

<p>The JVM has approximately 200 â€œopcodesâ€ to perform invocation of instructions, handle access to fields and control objects and arrays. The following table presents the types of invocation bytecode operations that were available before JDK version 7:</p>

<p>Opcode</p>

<p>Usage</p>

<p>Invokestatic</p>

<p>For static methods</p>

<p>Invokevirtual</p>

<p>For non-private instance methods</p>

<p>Invokespecial</p>

<p>For private instance</p>

<p>Invokeinterface</p>

<p>For the receiver that implements the interface</p>

<p>A simple invocation to a method starts from a given â€œCall Siteâ€, which is from where the request is initiated; it is assembled with the name of the method, the signature (access level, modifiers and return type) and the arguments that are processed by this method, the JVM will process this Call Site information and go through a set of operations: It is going to look for that methodâ€™s code within memory (Lookup), check if the types involved in the operations match (Type Checking), invokes the actual code (Branch) and then caches the location of that method so, if it is going to be needed again soon, the JVM already knows that memory address and speeds up the process (Cache).</p>

<p>normalCall</p>

<p>The new â€œInvokedynamicâ€ bytecode operation allows the JVM to customize how the resources for the Call Site are assembled (dynamically) and also perform a different set of operations within the JVM so the field or method can be accessed (invoked). Instead of the regular Call Site, it integrates bytecode (invokedynamic operation with name and signature) with a bootstrap method, this is the component that will connect the Call Site with the â€œMethod Handleâ€, once the handle finds the correct way of making this invocation occurs, the JVM will optimize the operation and the invokedynamic bytecode will be attached to the â€œTarget Methodâ€ to avoid processing all these steps again. In a scenario where a scripting language that is running within the JVM needs to access a specific function, it is going to initiate the process by providing the bootstrap method with the invokedynamic instructions (name of the function followed by arguments and the return type), the JVM will look for the function within a Method Table (list of functions that are not associated to any object or class) based on the arguments that are defined at runtime (Lookup), once it finds the function, it will perform some language-specific type checking (Type Checking) and then it will finish the bootstrap process connecting the Call Site with the Method Handle so it can be executed (Branch), this connection is performed only once but Call Sites can be connected to new Method Handles.</p>

<p>dynamicCall</p>

<p>If you want a more in depth explanation, I strongly recommend this blog post here:</p>

<p>http://niklasschlimm.blogspot.ie/2012/02/java-7-complete-invokedynamic-example.html</p>

<p>Monitoring the JVM while running a Nashorn application
We have reached the last part todayâ€™s post, itâ€™s time to diagnose the Rhinoceros (orâ€¦ at least, try).</p>

<p>diagnoseNashorn</p>

<p>Letâ€™s start with some Thread Dumps: if we run our testNashorn.jjs and take a few thread dumps (using the instructions documented in our previous post), this is what we get once we load them into our Thread Dump analyzer:</p>

<p>ThreadDumpNashorn</p>

<p>Thatâ€™s it, say goodbye to the good-old readable stack trace. On this first analysis we reinforced once more how this change of paradigm will affect the way Java Performance Analysis and Troubleshooting is done nowadays, the chain of execution presented on the stack trace of the â€œMainâ€ thread resembles bytecode instructions, the best clue to easily identify what initiated each set of instructions is the name of the Javascript file that is declared in the â€œjdk.nashorn.internal.scripts.Scriptâ€ class (it can be found at the bottom of the stack trace), there are some familiar things there like the JVM native and internal threads but the rest got pretty cryptic for me.</p>

<p>So, whatâ€™s our alternative? As far as I know, there isnâ€™t any. We can only use some arguments to run the program and get some debug data that is supposed to give us some clues as to where the calls are coming from, but it is not very clear. I believe that, if we grok the concepts behind â€˜invokedynamicâ€™, we can use the â€œâ€“print-codeâ€ Nashorn argument and produce some debugging output that can be interpreted based on the dynamic calls that are generated by the Nashorn engine:</p>

<p>â€“print-code</p>

<p>We can also get more verbose results with the following command:</p>

<p>jjs -Dnashorn.debug=true -Dnashorn.methodhandles.debug.stacktrace=true â€“log=codegen:info testNashorn.js
What if the program hangs during the execution of a particular function? Under the development phase is pretty easy to just attach a debugger and step through the function calls but what if we are troubleshooting something in the production environment? Iâ€™m not sure if we have a valid alternative to that, if you have any ideas, please share on the comment section below.</p>

<p>What about Heap Dumps? Letâ€™s see what we get when we take a Heap Dump during the execution of our testNashorn.js script:</p>

<p>HeapDumpNashorn</p>

<p>Yep, it also got a little weird here. Since we donâ€™t have packages and typed classes, thereâ€™s no way to easily track down where are our â€œClassesâ€ and the number/size of objects associated to them, I did some investigation and found this â€œjdk.nashorn.internal.scripts.JOâ€ object that apparently serves as a wrapper to the objects created through Javascript functions, the downside is that it doesnâ€™t separate the objects based on its â€œClassâ€ (at least I didnâ€™t find any parameter that pointed me anywhere near the â€œjdk.nashorn.internal.scripts.Script$Personâ€ object), so if you have 100 instances of â€˜Personâ€™ and 100 instances of â€˜Carâ€™, they will be mingled in this sea of â€˜JOâ€™ instances (I havenâ€™t tested other object forms yet, e.g., Object Literals; not sure if we would see something different). So, how do we easily keep track of the size of objects created from a given function()? Well, we could rely on the format of the attributes and play with OQL (Object Query Language) and isolate a given set of objects to determine how much space they are taking up, but thatâ€™s just messy. Currently, there are a few DEBUG parameters documented in â€œ$OPENJDK8_HOME/nashorn/docs/DEVELOPER_READMEâ€œ, some of them are quite interesting and might provide the answers we need, e.g.:</p>

<p>print(Debug.map(p));
print(Debug.dumpCounters());
Now, to conclude this post, I leave you with a message from Jim Laskey, this is one of the replies that he sent me when I was questioning his team about these concerns:</p>

<p>â€œThe next round of development will be focusing on tools, so what you are trying to accomplish will get easier. You have an opportunity to provide us guidance on thisâ€¦. Stack crawls will get better once we start working on debugging APIs.â€.</p>

<p>So there you have it, if you are interested in contribute to these debug APIs I hope this post can provide some guidance and/or raise awareness on the difficulties that we might face in a near future where we will be troubleshooting Nashorn-based enterprise applications.</p>

<p>Good Nashorning everyone! ğŸ˜€</p>

      

      </section>
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
